package org.joyapp.joyofpostfix

import java.util.*

// documentation to find at:
const val helpPDF: String = "https://github.com/Joy-of-Postfix/calculator/blob/main/JoyOfPostfix.pdf"

// ----- to stop processing
public var runvm: Boolean = false

// ----- constants
const val ctquote: String   = "'"
const val ctquote2: String  = "\""
const val ctdef: String     = "=="
const val cttrue: String    = "true"  // ???
const val ctfalse: String   = "false" // ???
const val ctact: String     = "!"
const val ctspecial: String = "()[]{}" + ctquote + ctquote2

// ----- error messages
const val ecalcstop: String  = "CALC-STOP"   // ???
const val ereturndo: String  = "RETURN-DO"   // ???
const val ebreakloop: String = "BREAK-LOOP"  // ???

const val ecomonlyparenend: String = ") without ( before"
const val ecomonlybracketend: String = "] without [ in front"
const val ecomonlycurlyend: String = "} without { before"
const val ecomcommtunexpend: String = "unexpected ending, ) missing"
const val ecomlistunexpend: String = "unexpected ending, ] missing"
const val ecomstringunexpend: String = "unexpected end of String scan"
const val ecom2notallowed: String = "# not allowed in lists"

const val einitarrayoverflow: String = "the pcounter exceeds the array size"
const val eidentnull: String = "Eval  >>>  ident is not defined"
const val edoacterr: String  = "doAct  >>>  can't react to this number"
const val efuncundef: String = "Function is not defined"
const val edeferr: String    =  "==  >>>  wrong use of define"
const val estacknull: String    = "  >>>  stack is null"
const val efloatexp: String     = "  >>>  float expected"
const val econsexp: String      = "  >>>  cons expected"
const val elistexp: String      = "  >>>  list expected"
const val elistorstrexp: String = "  >>>  list or string expected"
const val elistornumexp: String = "  >>>  list or float expected"
const val edivbyzero: String    = "  >>>  division by zero"
const val eidentexp: String     = "  >>>  ident expected"
const val eboolexp: String      = "  >>>  bool expected"
const val estringexp: String    = "  >>>  string expected"
const val estringnull: String   = "  >>>  string is null"
const val elistofstrexp: String = "  >>>  list of strings expected"
const val elistofnumexp: String = "  >>>  list of floats expected"
const val eoutofrange: String   = "  >>>  access out of range"
const val enoncompare: String   = "  >>>  types not comparable"
const val enonvalue: String     = "  >>>  no value for key"

// ----- function names
const val ctundefined: String = "undefined"
// const val ctquote: String = "'"
const val ctid: String   = "id"
const val ctstack: String = "stack"
const val ctunstack: String = "unstack"
const val ctdup: String  = "dup"
const val ctpop: String  = "pop"
const val ctswap: String = "swap"
const val ctover: String = "over"
const val ctrotate: String = "rotate"
const val ctrollup: String = "rollup"
const val ctrolldown: String = "rolldown"
const val ctfirst: String = "first"
const val ctrest: String  = "rest"
const val ctcons: String  = "cons"
const val ctuncons: String = "uncons"
const val ctswons: String  = "swons"
const val ctunswons: String = "unswons"
const val ctreverse: String = "reverse"
const val ctadd: String  = "+"
const val ctsub: String  = "-"
const val ctmul: String  = "*"
const val ctmul2: String = "×"
const val ctdiv: String  = "/"
const val ctdiv2: String = "÷"
const val ctmod: String  = "mod"
const val ctpow: String  = "pow"
const val ctpred: String = "pred"
const val ctsucc: String = "succ"
const val ctsign: String = "sign"
const val ctabs: String  = "abs"
const val ctneg: String  = "neg"
const val ctfloor: String = "floor"
const val ctceil: String  = "ceil"
const val cttrunc: String = "trunc"
const val ctint: String   = "int"
const val ctfrac: String  = "frac"
const val ctround: String = "round"
const val ctroundto: String = "roundto"
const val ctexp: String   = "exp"
const val ctlog: String   = "log"
const val ctlog10: String = "log10"
const val ctlog2: String  = "log2"
const val ctsq: String   = "sq"
const val ctsqrt: String = "sqrt"
const val ctcbrt: String = "cbrt"
const val ctpi: String   = "pi"
const val ctsin: String  = "sin"
const val ctcos: String  = "cos"
const val cttan: String  = "tan"
const val ctasin: String = "asin"
const val ctacos: String = "acos"
const val ctatan: String = "atan"
const val ctatan2: String = "atan2"
const val ctsinh: String = "sinh"
const val ctcosh: String = "cosh"
const val cttanh: String = "tanh"
const val ctrad: String  = "rad"
const val ctdeg: String  = "deg"
const val ctnot: String  = "not"
const val ctand: String  = "and"
const val ctor: String   = "or"
const val ctxor: String  = "xor"
const val cteq: String   = "="
const val ctne: String   = "<>"
const val ctneq: String  = "!="
const val ctlt: String   = "<"
const val ctgt: String   = ">"
const val ctle: String   = "<="
const val ctge: String   = ">="
const val ctmin: String  = "min"
const val ctmax: String  = "max"
const val cthas: String  = "has"
const val ctin: String   = "in"
const val ctsmall: String = "small"
const val ctnull: String  = "null"
const val ctlist: String  = "list"
const val ctleaf: String  = "leaf"
const val ctbool: String  = "bool"
const val ctconsp: String = "consp"
const val ctident: String = "ident"
const val ctfloat: String = "float"
const val ctstring: String = "string"
const val ctundef: String = "undef"
const val cttype: String  = "type"
const val ctname: String  = "name"
const val ctbody: String  = "body"
const val ctinfo: String  = "info"
const val ctuser: String  = "user"
const val ctbound: String = "bound"
const val ctintern: String = "intern"
const val ctindex: String = "index"
const val ctat: String    = "at"
const val ctof: String    = "of"
const val ctmake: String  = "make"
const val cttake: String  = "take"
const val ctdrop: String  = "drop"
const val ctconcat: String  = "concat"
const val ctswoncat: String = "swoncat"
const val ctfind: String    = "find"
const val ctcount: String   = "count"
const val ctiota: String    = "iota"
const val ctfromto: String  = "fromto"
const val ctsum: String   = "sum"
const val ctprod: String  = "prod"
const val ctget: String   = "get"
const val ctput: String   = "put"
const val ctsubstring: String = "substring"
const val ctindexof: String = "indexof"
const val ctupper: String = "upper"
const val ctlower: String = "lower"
const val ctcapitalize: String = "capitalize"
const val cttrim: String  = "trim"
const val cttriml: String = "triml"
const val cttrimr: String = "trimr"
const val cttrimpre: String = "trimpre"
const val ctchr: String   = "chr"
const val ctord: String   = "ord"
const val ctreplace: String  = "replace"
const val ctreplace1: String = "replace1"
const val ctsplit: String = "split"
const val ctjoin: String  = "join"
const val cti: String     = "i"
const val ctdip: String   = "dip"
const val ctdip2: String  = "dip2"
const val ctnullary: String = "nullary"
const val ctdo: String     = "do"
const val ctreturn: String = "return"
const val ctif: String     = "if"
const val ctbranch: String = "branch"
const val ctifte: String   = "ifte"
const val ctchoice: String = "choice"
const val cttimes: String = "times"
const val ctwhile: String = "while"
const val ctloop: String  = "loop"
const val ctbreak: String = "break"
const val ctstep: String  = "step"
const val ctmap: String   = "map"
const val ctfold: String  = "fold"
const val ctfilter: String = "filter"
const val ctsplit2: String = "split2"
const val ctcleave: String = "cleave"
const val ctprimrec: String = "primrec"
const val cttailrec: String = "tailrec"
const val ctgenrec: String  = "genrec"
const val ctlinrec: String  = "linrec"
const val ctbinrec: String  = "binrec"
const val cttry: String    = "try"
const val ctabort: String  = "abort"
const val cterror: String  = "error"
const val ctsize: String   = "size"
const val ctunpack: String = "unpack"
const val ctpack: String   = "pack"
const val ctparse: String  = "parse"  // position?
const val cttostr: String  = "tostr"
const val cttoval: String = "toval"
const val cttrytoval: String = "trytoval"
const val ctstrtod: String = "strtod"
const val cthextod: String = "hextod"
const val cttohex: String  = "tohex"
const val ctidentlist: String = "identlist"
const val ctidentdump: String = "identdump"
const val cthelpinfo: String = "helpinfo"
const val ctdeflines: String  = "deflines"
const val ctgc: String = "gc"

// for monad side-effects
const val ctdot: String   = "."
const val ctprint: String = "print"

// ----- Joy is a stack-based language
var stack: Any = Nil()
var quotenext: Boolean = false

class Nil {
    constructor() {}
}

class Cons {
    var addr: Any
    var decr: Any
    constructor(hd: Any, tl: Any) {  addr = hd ; decr = tl  }
}

class Ident {
    val pname: String
    var body: Any
    var info: String
    constructor(pn: String, bd: Any) {  pname = pn ; body = bd ; info = ""  }
}

// ----- output

fun toSequence(x: Any): String {
    var i: Any = x
    var s: String = ""
    var sp: String = ""
    while (i is Cons) {
        s = s + sp + toValue(i.addr)
        sp = " "
        i = i.decr
    }
    return s  }

fun toDoubleString(x: Any): String {
    val str = x.toString()
    val len = str.length
    if (len>=2) { if (str.substring(len-2,len) == ".0") return str.substring(0,len-2) }
    return str  }

fun toValue(x: Any): String {
    return when (x) {
        is Cons   -> "["+toSequence(x)+"]"
        is Nil    -> "[ ]"
        is Ident  -> x.pname
        is Double -> toDoubleString(x)
        is Int    -> "("+x.toString()+")"
        is Long   -> "(Long="+x.toString()+")"
        is String -> "\""+x+"\""
        true      -> cttrue
        false     -> ctfalse
        else      -> "(Printerror)"
    }  }

// ----- Joy virtual machine

class JoyVM {

    var maxproc: Int = 500
    var proc: Array<() -> Unit> = Array(maxproc, { initElement(it) })

    var pcounter: Int = 0
    var identlist: Any = Nil()

    var xmark: Ident = Ident("_mark",Nil())  // besser nicht in identlist

    var idundefined: Ident = newidentfunc(ctundefined,::fundefined)
    var iddef: Ident   = newidentfunc(ctdef,::fdef)
    var idact: Ident   = newidentfunc(ctact,::fact)
    var idquote: Ident = newidentfunc(ctquote,::fquote)
    var idid: Ident    = newidentfunc(ctid,::fid)
    var idstack: Ident = newidentfunc(ctstack,::fstack)
    var idunstack: Ident = newidentfunc(ctunstack,::funstack)
    var iddup: Ident  = newidentfunc(ctdup,::fdup)
    var idpop: Ident  = newidentfunc(ctpop,::fpop)
    var idswap: Ident = newidentfunc(ctswap,::fswap)
    var idover: Ident = newidentfunc(ctover,::fover)
    var idrotate: Ident = newidentfunc(ctrotate,::frotate)
    var idrollup: Ident = newidentfunc(ctrollup,::frollup)
    var idrolldown: Ident = newidentfunc(ctrolldown,::frolldown)
    var idfirst: Ident = newidentfunc(ctfirst,::ffirst)
    var idrest: Ident = newidentfunc(ctrest,::frest)
    var idcons: Ident = newidentfunc(ctcons,::fcons)
    var iduncons: Ident = newidentfunc(ctuncons,::funcons)
    var idswons: Ident = newidentfunc(ctswons,::fswons)
    var idunswons: Ident = newidentfunc(ctunswons,::funswons)
    var idreverse: Ident = newidentfunc(ctreverse,::freverse)
    var idadd: Ident = newidentfunc(ctadd,::fadd)
    var idsub: Ident = newidentfunc(ctsub,::fsub)
    var idmul: Ident = newidentfunc(ctmul,::fmul)
    var idmul2: Ident = newidentfunc(ctmul2,::fmul2)
    var iddiv: Ident = newidentfunc(ctdiv,::fdiv)
    var iddiv2: Ident = newidentfunc(ctdiv2,::fdiv2)
    var idmod: Ident = newidentfunc(ctmod,::fmod)
    var idpow: Ident = newidentfunc(ctpow,::fpow)
    var idpred: Ident = newidentfunc(ctpred,::fpred)
    var idsucc: Ident = newidentfunc(ctsucc,::fsucc)
    var idsign: Ident = newidentfunc(ctsign,::fsign)
    var idabs: Ident = newidentfunc(ctabs,::fabs)
    var idneg: Ident = newidentfunc(ctneg,::fneg)
    var idfloor: Ident = newidentfunc(ctfloor,::ffloor)
    var idceil: Ident = newidentfunc(ctceil,::fceil)
    var idtrunc: Ident = newidentfunc(cttrunc,::ftrunc)
    var idint: Ident = newidentfunc(ctint,::fint)
    var idfrac: Ident = newidentfunc(ctfrac,::ffrac)
    var idround: Ident = newidentfunc(ctround,::fround)
    var idroundto: Ident = newidentfunc(ctroundto,::froundto)
    var idexp: Ident = newidentfunc(ctexp,::fexp)
    var idlog: Ident = newidentfunc(ctlog,::flog)
    var idlog10: Ident = newidentfunc(ctlog10,::flog10)
    var idlog2: Ident = newidentfunc(ctlog2,::flog2)
    var idsq: Ident = newidentfunc(ctsq,::fsq)
    var idsqrt: Ident = newidentfunc(ctsqrt,::fsqrt)
    var idcbrt: Ident = newidentfunc(ctcbrt,::fcbrt)
    var idpi: Ident = newidentfunc(ctpi,::fpi)
    var idsin: Ident = newidentfunc(ctsin,::fsin)
    var idcos: Ident = newidentfunc(ctcos,::fcos)
    var idtan: Ident = newidentfunc(cttan,::ftan)
    var idasin: Ident = newidentfunc(ctasin,::fasin)
    var idacos: Ident = newidentfunc(ctacos,::facos)
    var idatan: Ident = newidentfunc(ctatan,::fatan)
    var idatan2: Ident = newidentfunc(ctatan2,::fatan2)
    var idsinh: Ident = newidentfunc(ctsinh,::fsinh)
    var idcosh: Ident = newidentfunc(ctcosh,::fcosh)
    var idtanh: Ident = newidentfunc(cttanh,::ftanh)
    var idrad: Ident = newidentfunc(ctrad,::frad)
    var iddeg: Ident = newidentfunc(ctdeg,::fdeg)
    var idnot: Ident = newidentfunc(ctnot,::fnot)
    var idand: Ident = newidentfunc(ctand,::fand)
    var idor: Ident = newidentfunc(ctor,::f_or)
    var idxor: Ident = newidentfunc(ctxor,::fxor)
    var ideq: Ident = newidentfunc(cteq,::feq)
    var idne: Ident = newidentfunc(ctne,::fne)
    var idneq: Ident = newidentfunc(ctneq,::fneq)
    var idlt: Ident = newidentfunc(ctlt,::flt)
    var idgt: Ident = newidentfunc(ctgt,::fgt)
    var idle: Ident = newidentfunc(ctle,::fle)
    var idge: Ident = newidentfunc(ctge,::fge)
    var idmin: Ident = newidentfunc(ctmin,::fmin)
    var idmax: Ident = newidentfunc(ctmax,::fmax)
    var idhas: Ident = newidentfunc(cthas,::fhas)
    var idin: Ident = newidentfunc(ctin,::fin)
    var idsmall: Ident = newidentfunc(ctsmall,::fsmall)
    var idnull: Ident  = newidentfunc(ctnull,::fnull)
    var idlist: Ident  = newidentfunc(ctlist,::flist)
    var idleaf: Ident = newidentfunc(ctleaf,::fleaf)
    var idbool: Ident = newidentfunc(ctbool,::fbool)
    var idconsp: Ident = newidentfunc(ctconsp,::fconsp)
    var idident: Ident = newidentfunc(ctident,::fident)
    var idfloat: Ident = newidentfunc(ctfloat,::ffloat)
    var idstring: Ident = newidentfunc(ctstring,::fstring)
    var idundef: Ident = newidentfunc(ctundef,::fundef)
    var idtype: Ident = newidentfunc(cttype,::ftype)
    var idname: Ident = newidentfunc(ctname,::fname)
    var idbody: Ident  = newidentfunc(ctbody,::fbody)
    var idinfo: Ident = newidentfunc(ctinfo,::finfo)
    var iduser: Ident = newidentfunc(ctuser,::fuser)
    var idbound: Ident = newidentfunc(ctbound,::fbound)
    var idintern: Ident = newidentfunc(ctintern,::fintern)
    var idindex: Ident = newidentfunc(ctindex,::findex)
    var idat: Ident = newidentfunc(ctat,::fat)
    var idof: Ident = newidentfunc(ctof,::fof)
    var idmake: Ident = newidentfunc(ctmake,::fmake)
    var idtake: Ident = newidentfunc(cttake,::ftake)
    var iddrop: Ident = newidentfunc(ctdrop,::fdrop)
    var idconcat: Ident = newidentfunc(ctconcat,::fconcat)
    var idswoncat: Ident = newidentfunc(ctswoncat,::fswoncat)
    var idfind: Ident = newidentfunc(ctfind,::ffind)
    var idcount: Ident = newidentfunc(ctcount,::fcount)
    var idiota: Ident = newidentfunc(ctiota,::fiota)
    var idfromto: Ident = newidentfunc(ctfromto,::ffromto)
    var idsum: Ident = newidentfunc(ctsum,::fsum)
    var idprod: Ident = newidentfunc(ctprod,::fprod)
    var idget: Ident = newidentfunc(ctget,::fget)
    var idput: Ident = newidentfunc(ctput,::fput)
    var idsubstring: Ident = newidentfunc(ctsubstring,::fsubstring)
    var idindexof: Ident = newidentfunc(ctindexof,::findexof)
    var idupper: Ident = newidentfunc(ctupper,::fupper)
    var idlower: Ident = newidentfunc(ctlower,::flower)
    var idcapitalize: Ident = newidentfunc(ctcapitalize,::fcapitalize)
    var idtrim: Ident = newidentfunc(cttrim,::ftrim)
    var idtriml: Ident = newidentfunc(cttriml,::ftriml)
    var idtrimr: Ident = newidentfunc(cttrimr,::ftrimr)
    var idtrimpre: Ident = newidentfunc(cttrimpre,::ftrimpre)
    var idchr: Ident = newidentfunc(ctchr,::fchr)
    var idord: Ident = newidentfunc(ctord,::ford)      // position? ,name?
    var idreplace: Ident = newidentfunc(ctreplace,::freplace)
    var idreplace1: Ident = newidentfunc(ctreplace1,::freplace1)
    var idsplit: Ident = newidentfunc(ctsplit,::fsplit)
    var idjoin: Ident = newidentfunc(ctjoin,::fjoin)
    var idi: Ident   = newidentfunc(cti,::fi)
    var iddip: Ident = newidentfunc(ctdip,::fdip)
    var iddip2: Ident = newidentfunc(ctdip2,::fdip2)
    var idnullary: Ident = newidentfunc(ctnullary,::fnullary)
    var iddo: Ident = newidentfunc(ctdo,::fdo)
    var idreturn: Ident = newidentfunc(ctreturn,::freturn)
    var idif: Ident = newidentfunc(ctif,::fif)
    var idbranch: Ident = newidentfunc(ctbranch,::fbranch)
    var idifte: Ident = newidentfunc(ctifte,::fifte)
    var idchoice: Ident = newidentfunc(ctchoice,::fchoice)
    var idtimes: Ident = newidentfunc(cttimes,::ftimes)
    var idwhile: Ident = newidentfunc(ctwhile,::fwhile)
    var idloop: Ident = newidentfunc(ctloop,::floop)
    var idbreak: Ident = newidentfunc(ctbreak,::fbreak)
    var idstep: Ident = newidentfunc(ctstep,::fstep)
    var idmap: Ident = newidentfunc(ctmap,::fmap)
    var idfold: Ident = newidentfunc(ctfold,::ffold)
    var idfilter: Ident = newidentfunc(ctfilter,::ffilter)
    var idsplit2: Ident = newidentfunc(ctsplit2,::fsplit2)
    var idcleave: Ident = newidentfunc(ctcleave,::fcleave)
    var idprimrec: Ident = newidentfunc(ctprimrec,::fprimrec)
    var idtailrec: Ident = newidentfunc(cttailrec,::ftailrec)
    var idgenrec: Ident = newidentfunc(ctgenrec,::fgenrec)
    var idlinrec: Ident = newidentfunc(ctlinrec,::flinrec)
    var idbinrec: Ident = newidentfunc(ctbinrec,::fbinrec)
    var idtry: Ident = newidentfunc(cttry,::ftry)  // test!
    var idabort: Ident = newidentfunc(ctabort,::fabort)
    var iderror: Ident = newidentfunc(cterror,::ferror)  // position?
    var idsize: Ident = newidentfunc(ctsize,::fsize)
    var idunpack: Ident = newidentfunc(ctunpack,::funpack)
    var idpack: Ident = newidentfunc(ctpack,::fpack)
    var idparse: Ident = newidentfunc(ctparse,::fparse)
    var idtostr: Ident = newidentfunc(cttostr,::ftostr)
    var idtoval: Ident = newidentfunc(cttoval,::ftoval)
    var idtrytoval: Ident = newidentfunc(cttrytoval,::ftrytoval)
    var idstrtod: Ident = newidentfunc(ctstrtod,::fstrtod)
    /*
    @kotlin.ExperimentalStdlibApi
    var idhextod: Ident = newidentfunc(cthextod,::fhextod)
    */
    /*
    @kotlin.ExperimentalStdlibApi
    var idtohex: Ident = newidentfunc(cttohex,::ftohex)
    */
    var ididentlist: Ident = newidentfunc(ctidentlist,::fidentlist)
    var ididentdump: Ident = newidentfunc(ctidentdump,::fidentdump)
    var idhelpinfo: Ident = newidentfunc(cthelpinfo,::fhelpinfo)
    var idgc: Ident = newidentfunc(ctgc,::fgc)

    constructor() {  init()  }

    fun init() {
        // identlist = Cons(123,Cons(456.toLong(),xnil))
    }

    fun initElement(x: Int): () -> Unit { return ::fundefined }

    fun newidentfunc(pn: String, fn: ()->Unit ): Ident {
        pcounter = pcounter + 1
        if (pcounter >= maxproc) throw Exception(einitarrayoverflow)
        proc[pcounter] = fn
        val id: Ident = Ident(pn,pcounter)
        identlist = Cons(id,identlist)
        return id  }

    fun identlistPut(pn: String, v: Any): Ident {
        val id: Ident = Ident(pn,v)
        identlist = Cons(id,identlist)
        return id  }

    fun isLong(str: String) = (str.toLongOrNull() != null)
    fun isDouble(str: String) = (str.toDoubleOrNull() != null)

    // true und false extra compilieren !!!
    var ix: Int = 0
    var txt: String = ""
    var item: String = ""
    var cstack: Any = Nil()

// ----- scanner

    fun scanItem(): String {
        var ch: String = " "
        var quit : Boolean
        while ((ix<txt.length) and (ch<=" ")) {
            ch = txt.substring(ix,ix+1)
            ix = ix.inc() }
        if (ch<=" ") return ""
        if (ctspecial.indexOf(ch)>=0) return ch
        ix = ix.dec()
        val k: Int = ix    // val k: Int ,für größere Zahlen ?
        do { ix = ix.inc()
            if (ix>=txt.length) { quit = true }
            else { ch = txt.substring(ix,ix+1)
                quit = ((ctspecial.indexOf(ch)>=0) or (ch<=" ")) }
        } while (!quit)
        return txt.substring(k,ix) }

    //fun clistPut(x: Any) {  cstack = Cons(x,cstack)  }  // ersetzen!

// ----- compiler

    fun comComment() {
        item = scanItem()
        while (item!=")") {
            if (item=="") throw Exception(ecomcommtunexpend)
            item = scanItem()
        }  }

    fun comComment2() {  ix = txt.length;  item = ""  }

    fun cbackcons(i: Cons): Cons {
        var stack: Cons = i
        var p: Any
        var ref: Any = Nil()
        while (stack.addr!=xmark) {
            p = stack
            stack = stack.decr as Cons
            p.decr = ref
            ref = p  }
        stack.addr = ref
        return stack  }

    fun comList() {
        cstack = Cons(xmark,cstack)
        item = scanItem()
        while (item!="]") {
            when (item) {
                ""       -> throw Exception(ecomlistunexpend)
                "("       -> comComment()
                ")"       -> throw Exception(ecomonlyparenend)
                "["       -> comList()
                // "]"       -> throw Exception(ecomonlybracketend)
                "{"       -> comCurly()
                "}"       -> throw Exception(ecomonlycurlyend)
                ctquote   -> cstack = Cons(idquote,cstack)
                ctquote2  -> comString()
                ctdef     -> cstack = Cons(iddef,cstack) // ??? oder exception oder _s einfügen?
                cttrue    -> cstack = Cons(true,cstack)
                ctfalse   -> cstack = Cons(false,cstack)
                "#"       -> throw Exception(ecom2notallowed)
                else      -> atom(item)  }
            item = scanItem()  }
        cstack = cbackcons(cstack as Cons)  }

    fun comCurly() {
        cstack = Cons("{",cstack)
    }

    fun comString() {
        val k = ix
        do {  ix = ix.inc()  // backslash einbauen!
            if (ix>txt.length) throw Exception(ecomstringunexpend)
        } while (txt.substring(ix-1,ix)!=ctquote2)
        cstack = Cons(txt.substring(k,ix-1),cstack)
    }

    fun findIdent(str: String): Any {
        var seq: Any = identlist
        var found: Any = Nil()
        while ((seq is Cons) and (found is Nil)) {
            if (((seq as Cons).addr as Ident).pname == str)
                found = (seq as Cons).addr
            else seq = seq.decr }
        return found  }

    fun toIdent(str: String): Any {
        val id: Any = findIdent(str)
        // println("find = ${toValue(id)}") // auskommentieren
        if (id is Nil) return identlistPut(str,Nil())
        else return id  }

    fun atom(str: String) {
        if (isDouble(str)) cstack = Cons(str.toDouble(),cstack)
        else cstack = Cons(toIdent(str),cstack)  }

    fun parse(str: String): Any {
        // var ix: Int = 0 // größere Zahlen?
        // var it: String
        // var cstack: Any = Nil()
        txt = str
        ix = 0
        cstack = Nil()
        item = scanItem()
        while (item != "") {
            when (item) {
                //  ""      ---> while
                "("       -> comComment()
                ")"       -> throw Exception(ecomonlyparenend)
                "["       -> comList()
                "]"       -> throw Exception(ecomonlybracketend)
                "{"       -> comCurly()
                "}"       -> throw Exception(ecomonlycurlyend)
                ctquote   -> cstack = Cons(idquote,cstack)
                ctquote2  -> comString()
                ctdef     -> cstack = Cons(iddef,cstack) // ??? oder exception oder _s einfügen?
                cttrue    -> cstack = Cons(true,cstack)
                ctfalse   -> cstack = Cons(false,cstack)
                "#"       -> comComment2()
                else      -> atom(item)  }
            item = scanItem()  }
        txt = ""
        item = ""
        val res: Any = cstack
        cstack = Nil()
        return nreverse(res)
    }  // außerhalb try verwenden?

    fun nreverse(i: Any): Any {
        var n: Any = i
        var p: Any
        var reseq: Any = Nil()
        while (n is Cons) {
            p = n
            n = n.decr
            p.decr = reseq
            reseq = p }
        return reseq  }

    fun creverse(x: Any): Any {
        var r: Any = Nil()
        var i: Any = x
        while (i is Cons) {
            r = Cons(i.addr,r)
            i = i.decr
        }
        return r  }

    fun calc(txt: String) {
        val clist: Any = parse(txt)
        if (clist is Cons) {
            if ((clist.addr is Ident) and (clist.decr is Cons)) {
                val id: Ident = clist.addr as Ident
                val dlist: Cons = clist.decr as Cons
                if (dlist.addr == iddef) {
                    id.info = txt
                    id.body = dlist.decr
                } else run(clist)
            } else run(clist)
        }  } // function-use in try einbetten

// ----- Joy interpreter

    var efun: Any = Nil()
    var eid:  Any = Nil()

    fun eval() {
        if (!runvm) throw Exception(ecalcstop)
        when (efun) {
            is Cons -> {
                var i: Any = efun
                while (i is Cons) {
                    if (!runvm) throw Exception(ecalcstop)
                    efun = i.addr
                    if (quotenext) {  quotenext = false
                                      stack = Cons(efun,stack)  }
                    else if (efun !is Ident) stack = Cons(efun,stack)
                    else {
                        eid = efun
                        efun = (efun as Ident).body
                        if (efun is Int) proc[efun as Int]()
                        else if (efun is Cons) eval()
                        else throw Exception(eidentnull+" - "+toValue(eid))
                    }
                    i = i.decr
                }  }
            is Ident -> {
                eid = efun
                efun = (efun as Ident).body
                if (efun is Int) proc[efun as Int]()
                else if (efun is Cons) eval()
                else throw Exception(eidentnull+" - "+toValue(eid))
            }
            is Nil   -> {  }
            else     -> stack = Cons(efun,stack)
        }
        efun = Nil()  }

    fun run(x: Any) {
        runvm = true
        efun = x
        eval()
        runvm = false
        // efun = Nil()
    }

// ----- build-in functions

    fun fundefined() {  throw Exception(efuncundef)  }

    fun fdef()   {  throw Exception(edeferr)  }

    fun fact()   {  stack = Cons(idact,stack)  }     //  ???

    fun fquote() {  quotenext = true  }

    fun fid()    {  }

    fun fstack() {  stack = Cons(stack,stack)  }

    fun funstack() {
        if (stack !is Cons) throw Exception(ctunstack + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (!((x is Cons) or (x is Nil))) throw Exception(ctunstack + elistexp)
        stack = x
    }

    fun fdup() {
        if (stack !is Cons) throw Exception(ctdup + estacknull)
        val x = (stack as Cons).addr
        stack = Cons(x,stack)
    }

    fun fpop() {
        if (stack !is Cons) throw Exception(ctpop + estacknull)
        stack = (stack as Cons).decr
    }

    fun fswap() {
        if (stack !is Cons) throw Exception(ctswap + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctswap + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        stack = Cons(x,Cons(y,stack))
    }

    fun fover() {
        if (stack !is Cons) throw Exception(ctover + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctover + estacknull)
        val y = (stack as Cons).addr
        //stack = (stack as Cons).decr
        //stack = Cons(y,Cons(x,Cons(y,stack)))
        stack = Cons(y,Cons(x,stack))
    }

    fun frotate() {
        if (stack !is Cons) throw Exception(ctrotate + estacknull)
        val z = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctrotate + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctrotate + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        stack = Cons(x,Cons(y,Cons(z,stack)))
    }

    fun frollup() {
        if (stack !is Cons) throw Exception(ctrollup + estacknull)
        val z = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctrollup + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctrollup + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        stack = Cons(y,Cons(x,Cons(z,stack)))
    }

    fun frolldown() {
        if (stack !is Cons) throw Exception(ctrolldown + estacknull)
        val z = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctrolldown + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctrolldown + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        stack = Cons(x,Cons(z,Cons(y,stack)))
    }

    // d words...

    fun ffirst() {
        if (stack !is Cons) throw Exception(ctfirst + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x is Cons) stack = Cons(x.addr,stack)
        else if (x is Nil) stack = Cons(x,stack)
        else throw Exception(ctfirst + elistexp)
    }

    fun frest() {
        if (stack !is Cons) throw Exception(ctrest + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x is Cons) stack = Cons(x.decr,stack)
        else if (x is Nil) stack = Cons(x,stack)
        else throw Exception(ctrest + elistexp)
    }

    fun fcons() {
        if (stack !is Cons) throw Exception(ctcons + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctcons + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (!((y is Cons) or (y is Nil))) throw Exception(ctcons + elistexp)
        stack = Cons(Cons(x,y),stack)
    }

    fun funcons() {
        if (stack !is Cons) throw Exception(ctuncons + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Cons) throw Exception(ctuncons + econsexp)
        stack = Cons(x.decr,Cons(x.addr,stack))
    }

    fun fswons() {
        if (stack !is Cons) throw Exception(ctswons + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctswons + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (!((x is Cons) or (x is Nil))) throw Exception(ctswons + elistexp)
        stack = Cons(Cons(y,x),stack)
    }

    fun funswons() {
        if (stack !is Cons) throw Exception(ctunswons + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Cons) throw Exception(ctunswons + econsexp)
        stack = Cons(x.addr,Cons(x.decr,stack))
    }

    fun freverse() {
        if (stack !is Cons) throw Exception(ctreverse + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if ((x is Cons) or (x is Nil)) stack = Cons(creverse(x),stack)
        else if (x is String) stack = Cons(x.reversed(),stack)
        else throw Exception(ctreverse + elistorstrexp)
    }

    fun fadd() {
        if (stack !is Cons) throw Exception(ctadd + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctadd + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctadd + efloatexp)
        if (y !is Double) throw Exception(ctadd + efloatexp)
        stack = Cons((x + y),stack)
    }

    fun fsub() {
        if (stack !is Cons) throw Exception(ctsub + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctsub + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctsub + efloatexp)
        if (y !is Double) throw Exception(ctsub + efloatexp)
        stack = Cons((x - y),stack)
    }

    fun fmul() {
        if (stack !is Cons) throw Exception(ctmul + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctmul + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctmul + efloatexp)
        if (y !is Double) throw Exception(ctmul + efloatexp)
        stack = Cons((x * y),stack)
    }

    fun fmul2() {
        if (stack !is Cons) throw Exception(ctmul2 + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctmul2 + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctmul2 + efloatexp)
        if (y !is Double) throw Exception(ctmul2 + efloatexp)
        stack = Cons((x * y),stack)
    }

    fun fdiv() {
        if (stack !is Cons) throw Exception(ctdiv + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctdiv + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctdiv + efloatexp)
        if (y !is Double) throw Exception(ctdiv + efloatexp)
        if (y == 0.0) throw Exception(ctdiv + edivbyzero)
        stack = Cons((x / y),stack)
    }

    fun fdiv2() {
        if (stack !is Cons) throw Exception(ctdiv2 + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctdiv2 + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctdiv2 + efloatexp)
        if (y !is Double) throw Exception(ctdiv2 + efloatexp)
        if (y == 0.0) throw Exception(ctdiv2 + edivbyzero)
        stack = Cons((x / y),stack)
    }

    fun fmod() {
        if (stack !is Cons) throw Exception(ctmod + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctmod + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctmod + efloatexp)
        if (y !is Double) throw Exception(ctmod + efloatexp)
        val z: Double = x.mod(y)
        stack = Cons(z,stack)
    }

    fun freci() {}

    fun fpow() {
        if (stack !is Cons) throw Exception(ctpow + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctpow + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctpow + efloatexp)
        if (y !is Double) throw Exception(ctpow + efloatexp)
        stack = Cons(Math.pow(x,y),stack)
    }

    fun froot() {}

    fun fpred() {
        if (stack !is Cons) throw Exception(ctpred + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctpred + efloatexp)
        stack = Cons((x - 1.0),stack)
    }

    fun fsucc() {
        if (stack !is Cons) throw Exception(ctsucc + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctsucc + efloatexp)
        stack = Cons((x + 1.0),stack)
    }

    fun fsign() {
        if (stack !is Cons) throw Exception(ctsign + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctsign + efloatexp)
        stack = Cons(Math.signum(x),stack)
    }

    fun fabs() {
        if (stack !is Cons) throw Exception(ctabs + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctabs + efloatexp)
        stack = Cons(Math.abs(x),stack)
    }

    fun fneg() {
        if (stack !is Cons) throw Exception(ctneg + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctneg + efloatexp)
        stack = Cons(-x,stack)
    }

    fun ffloor() {
        if (stack !is Cons) throw Exception(ctfloor + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctfloor + efloatexp)
        stack = Cons(Math.floor(x),stack)
    }

    fun fceil() {
        if (stack !is Cons) throw Exception(ctceil + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctceil + efloatexp)
        stack = Cons(Math.ceil(x),stack)
    }

    fun ftrunc() {
        if (stack !is Cons) throw Exception(cttrunc + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(cttrunc + efloatexp)
        stack = Cons(x.toLong().toDouble(),stack)
    }

    fun fint() {
        if (stack !is Cons) throw Exception(ctint + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctint + efloatexp)
        stack = Cons(x.toLong().toDouble(),stack)
    }

    fun ffrac() {
        if (stack !is Cons) throw Exception(ctfrac + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctfrac + efloatexp)
        stack = Cons(x - (x.toLong().toDouble()),stack)
    }

    fun fround() {
        if (stack !is Cons) throw Exception(ctround + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctround + efloatexp)
        stack = Cons(Math.round(x).toDouble(),stack)
    }

    fun Double.roundTo(decimals: Int): Double {
        var multiplier = 1.0
        repeat(decimals) { multiplier *= 10 }
        return Math.round(this * multiplier) / multiplier
    }

    fun froundto() {
        if (stack !is Cons) throw Exception(ctroundto + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctroundto + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctroundto + efloatexp)
        if (y !is Double) throw Exception(ctroundto + efloatexp)
        stack = Cons(x.roundTo(Math.round(y).toInt()),stack)
    }

    fun fexp() {
        if (stack !is Cons) throw Exception(ctexp + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctexp + efloatexp)
        stack = Cons(Math.exp(x),stack)
        // Infinity?
    }

    fun flog() {
        if (stack !is Cons) throw Exception(ctlog + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctlog + efloatexp)
        stack = Cons(Math.log(x),stack)
        // -Infinity?
    }

    fun flog10() {
        if (stack !is Cons) throw Exception(ctlog10 + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctlog10 + efloatexp)
        stack = Cons(Math.log10(x),stack)
        // -Infinity?
    }

    fun flog2() {
        if (stack !is Cons) throw Exception(ctlog2 + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctlog2 + efloatexp)
        stack = Cons(Math.log10(x)/Math.log10(2.0),stack)
        // -Infinity?
    }

    fun fsq() {
        if (stack !is Cons) throw Exception(ctsq + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctsq + efloatexp)
        stack = Cons((x * x),stack)
    }

    fun fsqrt() {
        if (stack !is Cons) throw Exception(ctsqrt + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctsqrt + efloatexp)
        stack = Cons(Math.sqrt(x),stack)
        // NaN?
    }

    fun fcbrt() {
        if (stack !is Cons) throw Exception(ctcbrt + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctcbrt + efloatexp)
        stack = Cons(Math.cbrt(x),stack)
    }

    fun fpi() {  stack = Cons(Math.PI,stack)  }

    fun fsin() {
        if (stack !is Cons) throw Exception(ctsin + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctsin + efloatexp)
        stack = Cons(Math.sin(x),stack)
    }

    fun fcos() {
        if (stack !is Cons) throw Exception(ctcos + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctcos + efloatexp)
        stack = Cons(Math.cos(x),stack)
    }

    fun ftan() {
        if (stack !is Cons) throw Exception(cttan + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(cttan + efloatexp)
        stack = Cons(Math.tan(x),stack)
        // overflow?
    }

    fun fasin() {
        if (stack !is Cons) throw Exception(ctasin + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctasin + efloatexp)
        stack = Cons(Math.asin(x),stack)
        // NaN?
    }

    fun facos() {
        if (stack !is Cons) throw Exception(ctacos + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctacos + efloatexp)
        stack = Cons(Math.acos(x),stack)
        // NaN?
    }

    fun fatan() {
        if (stack !is Cons) throw Exception(ctatan + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctatan + efloatexp)
        stack = Cons(Math.atan(x),stack)
    }

    fun fatan2() {
        if (stack !is Cons) throw Exception(ctatan2 + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctatan2 + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (y !is Double) throw Exception(ctatan2 + efloatexp)
        if (x !is Double) throw Exception(ctatan2 + efloatexp)
        stack = Cons(Math.atan2(y,x),stack)
    }

    fun fsinh() {
        if (stack !is Cons) throw Exception(ctsinh + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctsinh + efloatexp)
        stack = Cons(Math.sinh(x),stack)
        // overflow?
    }

    fun fcosh() {
        if (stack !is Cons) throw Exception(ctcosh + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctcosh + efloatexp)
        stack = Cons(Math.cosh(x),stack)
        // overflow?
    }

    fun ftanh() {
        if (stack !is Cons) throw Exception(cttanh + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(cttanh + efloatexp)
        stack = Cons(Math.tanh(x),stack)
        // overflow?
    }

    fun frad() {
        if (stack !is Cons) throw Exception(ctrad + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctrad + efloatexp)
        stack = Cons(Math.toRadians(x),stack)
    }

    fun fdeg() {
        if (stack !is Cons) throw Exception(ctdeg + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctdeg + efloatexp)
        stack = Cons(Math.toDegrees(x),stack)
    }

    fun fnot() {
        if (stack !is Cons) throw Exception(ctnot + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Boolean) throw Exception(ctnot + eboolexp)
        stack = Cons(!x,stack)
    }

    fun fand() {
        if (stack !is Cons) throw Exception(ctand + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctand + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Boolean) throw Exception(ctand + eboolexp)
        if (y !is Boolean) throw Exception(ctand + eboolexp)
        stack = Cons((x and y),stack)
    }

    fun f_or() {
        if (stack !is Cons) throw Exception(ctor + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctor + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Boolean) throw Exception(ctor + eboolexp)
        if (y !is Boolean) throw Exception(ctor + eboolexp)
        stack = Cons((x or y),stack)
    }

    fun fxor() {
        if (stack !is Cons) throw Exception(ctxor + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctxor + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Boolean) throw Exception(ctxor + eboolexp)
        if (y !is Boolean) throw Exception(ctxor + eboolexp)
        stack = Cons((x xor y),stack)
    }

    fun isEq(a: Any, b: Any): Boolean {
        return when (a) {
            is Double  -> (a == b)
            is String  -> (a == b)
            is Ident   -> (a == b)
            is Cons    -> {  if (b !is Cons) false
                             else if (!isEq(a.addr,b.addr)) false
                             else isEq(a.decr,b.decr)
                          }
            is Nil     -> (b is Nil)
            is Boolean -> (a == b)
            else       -> false
        }  }

    fun isLess(a: Any, b: Any, eid: Ident): Boolean {
        return when (a) {
            is Double  -> {  if (b is Double) (a < b)
                             else throw Exception(toValue(eid) + enoncompare)  }
            is String  -> {  if (b is String) (a < b)
                             else throw Exception(toValue(eid) + enoncompare)  }
            is Ident   -> {  if (b is Ident) (a.pname < b.pname)
                             else throw Exception(toValue(eid) + enoncompare)  }
            // is Cons    -> {}
            // is Nil     -> {}
            is Boolean -> {  if (b is Boolean) (a < b)
                             else throw Exception(toValue(eid) + enoncompare)  }
            else       -> {  throw Exception(toValue(eid) + enoncompare)  }
        }  }

    fun feq() {
        if (stack !is Cons) throw Exception(cteq + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(cteq + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        stack = Cons(isEq(x,y),stack)
    }

    fun fne() {
        if (stack !is Cons) throw Exception(ctne + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctne + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        stack = Cons(!isEq(x,y),stack)
    }

    fun fneq() {
        if (stack !is Cons) throw Exception(ctneq + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctneq + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        stack = Cons(!isEq(x,y),stack)
    }

    fun flt() {
        if (stack !is Cons) throw Exception(ctlt + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctlt + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        val z = isLess(x,y,idlt)
        stack = Cons(z,stack)
    }

    fun fgt() {
        if (stack !is Cons) throw Exception(ctgt + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctgt + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        val z = isLess(y,x,idgt)
        stack = Cons(z,stack)
    }

    fun fle() {
        if (stack !is Cons) throw Exception(ctle + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctle + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        val z = !isLess(y,x,idle)
        stack = Cons(z,stack)
    }

    fun fge() {
        if (stack !is Cons) throw Exception(ctge + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctge + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        val z = !isLess(x,y,idge)
        stack = Cons(z,stack)
    }

    fun fmin() {
        if (stack !is Cons) throw Exception(ctmin + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctmin + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (isLess(x,y,idmin)) stack = Cons(x,stack)
        else stack = Cons(y,stack)
    }

    fun fmax() {
        if (stack !is Cons) throw Exception(ctmax + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctmax + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (isLess(x,y,idmax)) stack = Cons(y,stack)
        else stack = Cons(x,stack)
    }

    fun inList(x: Any, z: Any): Boolean {
        var i: Any = z
        while (i is Cons) {  if (isEq(x,i.addr)) return true
                             else i = i.decr  }
        return false  }

    fun fhas() {
        if (stack !is Cons) throw Exception(cthas + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(cthas + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (!((x is Cons) or (x is Nil))) throw Exception(cthas + elistexp)
        stack = Cons(inList(y,x),stack)
    }

    fun fin() {
        if (stack !is Cons) throw Exception(ctin + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctin + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (!((y is Cons) or (y is Nil))) throw Exception(ctin + elistexp)
        stack = Cons(inList(x,y),stack)
    }

    fun fsmall() {
        if (stack !is Cons) throw Exception(ctsmall + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        val b: Boolean = when (x) {
            is Nil  -> true
            is Cons -> (x.decr !is Cons)
            0.0     -> true
            1.0     -> true
            else    -> false
        }
        stack = Cons(b,stack)
    }

    fun fnull() {
        if (stack !is Cons) throw Exception(ctnull + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        stack = Cons(((x is Nil) or (x == 0.0)),stack)
    }

    fun flist() {
        if (stack !is Cons) throw Exception(ctlist + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        stack = Cons(((x is Cons) or (x is Nil)),stack)
    }

    fun fleaf() {
        if (stack !is Cons) throw Exception(ctleaf + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        stack = Cons(!((x is Cons) or (x is Nil)),stack)
    }

    fun fbool() {    // name?
        if (stack !is Cons) throw Exception(ctbool + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        stack = Cons((x is Boolean),stack)
    }

    fun fconsp() {
        if (stack !is Cons) throw Exception(ctconsp + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        stack = Cons((x is Cons),stack)
    }

    fun fident() {
        if (stack !is Cons) throw Exception(ctident + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        stack = Cons((x is Ident),stack)
    }

    fun ffloat() {
        if (stack !is Cons) throw Exception(ctfloat + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        stack = Cons((x is Double),stack)
    }

    fun fstring() {
        if (stack !is Cons) throw Exception(ctstring + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        stack = Cons((x is String),stack)
    }

    fun fundef() {
        if (stack !is Cons) throw Exception(ctundef + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        stack = Cons((x == idundef),stack)
    }

    fun getType(x: Any): Any {
        return when (x) {
            is Cons    -> idcons
            is Ident   -> idident
            is Double  -> idfloat
            is String  -> idstring
            is Boolean -> idbool
            is Nil     -> idnull
            is Int     -> "Int"     // ?
            is Long    -> "Long"    // ?
            else       -> idundef
        }  }

    fun ftype() {
        if (stack !is Cons) throw Exception(cttype + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        stack = Cons(getType(x),stack)
    }

    fun fname() {
        if (stack !is Cons) throw Exception(ctname + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x is Ident) stack = Cons(x.pname,stack)
        else throw Exception(ctname + eidentexp)
    }

    fun fbody() {
        if (stack !is Cons) throw Exception(ctbody + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Ident) throw Exception(ctbody + eidentexp)
        val y = x.body
        when (y) {
            is Int  -> stack = Cons(y.toDouble(),stack)
            is Cons -> stack = Cons(y,stack)
            else    -> stack = Cons(idundef,stack)
        }  }

    fun finfo() {
        if (stack !is Cons) throw Exception(ctinfo + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x is Ident) stack = Cons(x.info,stack)
        else throw Exception(ctinfo + eidentexp)
    }

    fun fuser() {
        if (stack !is Cons) throw Exception(ctuser + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Ident) throw Exception(ctuser + eidentexp)
        stack = Cons((x.body is Cons),stack)
    }

    fun fbound() {
        if (stack !is Cons) throw Exception(ctbound + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Ident) throw Exception(ctbound + eidentexp)
        stack = Cons((x.body !is Nil),stack)
    }

    fun fintern() {
        if (stack !is Cons) throw Exception(ctintern + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is String) throw Exception(ctintern + estringexp)
        stack = Cons(toIdent(x),stack)
    }

    fun findex() {
        if (stack !is Cons) throw Exception(ctindex + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctindex + efloatexp)
        var n: Long = Math.round(x)
        var i: Any = stack
        if (n < 0) throw Exception(ctindex + eoutofrange)
        if (n == 0.toLong()) stack = Cons(x,stack)
        else {
            while ((n > 1) and (i is Cons)) {  i = (i as Cons).decr ; n = n - 1  }
            if (i !is Cons) throw Exception(ctindex + eoutofrange)
            if (n > 1) throw Exception(ctindex + eoutofrange)
            stack = Cons(i.addr,stack)
        }  }

    fun selectAt(a: Any, x: Double, eid: Ident): Any {
        var i: Any = a
        var n: Long = Math.round(x)
        if (n <= 0.toLong()) throw Exception(toValue(eid) + eoutofrange)
        while ((n > 1) and (i is Cons)) {  i = (i as Cons).decr ; n = n - 1  }
        if (i !is Cons) throw Exception(toValue(eid) + eoutofrange)
        if (n > 1) throw Exception(toValue(eid) + eoutofrange)
        return i.addr
    }

    fun fat() {
        if (stack !is Cons) throw Exception(ctat + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctat + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (!((x is Cons) or (x is Nil))) throw Exception(ctat + elistexp)
        if (y !is Double) throw Exception(ctat + efloatexp)
        val z: Any = selectAt(x,y,idat)
        stack = Cons(z,stack)
    }

    fun fof() {
        if (stack !is Cons) throw Exception(ctof + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctof + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctof + efloatexp)
        if (!((y is Cons) or (y is Nil))) throw Exception(ctof + elistexp)
        val z: Any = selectAt(y,x,idof)
        stack = Cons(z,stack)
    }

    fun fset() {}

    fun fmake() {
        if (stack !is Cons) throw Exception(ctmake + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctmake + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (y !is Double) throw Exception(ctmake + efloatexp)
        var n: Long = Math.round(y)
        var res: Any = Nil()
        while (n > 0) {  res = Cons(x,res) ; n = n - 1  }
        stack = Cons(res,stack)
    }

    fun ftake() {
        if (stack !is Cons) throw Exception(cttake + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(cttake + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (!((x is Cons) or (x is Nil))) throw Exception(cttake + elistexp)
        if (y !is Double) throw Exception(cttake + efloatexp)
        var n: Long = Math.round(y)
        var i: Any = x
        var res: Any = Nil()
        while ((n > 0) and (i is Cons)) {  res = Cons((i as Cons).addr,res)
                                           n = n - 1
                                           i = i.decr
                                        }
        stack = Cons(nreverse(res),stack)
    }

    fun fdrop() {
        if (stack !is Cons) throw Exception(ctdrop + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctdrop + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (!((x is Cons) or (x is Nil))) throw Exception(ctdrop + elistexp)
        if (y !is Double) throw Exception(ctdrop + efloatexp)
        var n: Long = Math.round(y)
        var i: Any = x
        while ((n > 0) and (i is Cons)) {  n = n - 1 ; i = (i as Cons).decr  }
        stack = Cons(i,stack)
    }

    fun fconcat() {
        if (stack !is Cons) throw Exception(ctconcat + estacknull)
        var y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctconcat + estacknull)
        var x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x is String) {
            if (y !is String) throw Exception(ctconcat + estringexp)
            stack = Cons((x + y),stack)
        } else if ((x is Cons) or (x is Nil)) {
            if (!((y is Cons) or (y is Nil))) throw Exception(ctconcat + elistexp)
            var z: Any = Nil()
            while (x is Cons) {  z = Cons(x.addr,z) ; x = x.decr  }
            var p: Any      // y = Restliste
            while (z is Cons) {
                p = z
                z = z.decr
                p.decr = y
                y = p
            }
            stack = Cons(y,stack)
        } else throw Exception(ctconcat + elistorstrexp)
    }

    fun fswoncat() {
        if (stack !is Cons) throw Exception(ctswoncat + estacknull)
        var x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctswoncat + estacknull)
        var y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (y is String) {
            if (x !is String) throw Exception(ctswoncat + estringexp)
            stack = Cons((x + y),stack)
        } else if ((y is Cons) or (y is Nil)) {
            if (!((x is Cons) or (x is Nil))) throw Exception(ctswoncat + elistexp)
            var z: Any = Nil()
            while (x is Cons) {  z = Cons(x.addr,z) ; x = x.decr  }
            var p: Any      // y = Restliste
            while (z is Cons) {
                p = z
                z = z.decr
                p.decr = y
                y = p
            }
            stack = Cons(y,stack)
        } else throw Exception(ctswoncat + elistorstrexp)
    }

    fun ffind() {
        if (stack !is Cons) throw Exception(ctfind + estacknull)
        var y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctfind + estacknull)
        var x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (!((x is Cons) or (x is Nil))) throw Exception(ctfind + elistexp)
        var i: Any = x
        var n: Double = 0.0
        while (i is Cons) {
            n = n + 1.0
            if (isEq(i.addr,y)) break
            else i = i.decr
        }
        if (i is Cons) stack = Cons(n,stack)
        else stack = Cons(0.0,stack)
    }

    fun fcount() {
        if (stack !is Cons) throw Exception(ctcount + estacknull)
        var y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctcount + estacknull)
        var x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (!((x is Cons) or (x is Nil))) throw Exception(ctcount + elistexp)
        var i: Any = x
        var n: Double = 0.0
        while (i is Cons) {
            if (isEq(i.addr,y)) n = n + 1.0
            i = i.decr
        }
        stack = Cons(n,stack)
    }

    fun fiota() {
        if (stack !is Cons) throw Exception(ctiota + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctiota + efloatexp)
        var n: Long = Math.round(x)
        var res: Any = Nil()
        while (n > 0) {  res = Cons(n.toDouble(),res) ; n = n - 1  }
        stack = Cons(res,stack)
    }

    fun ffromto() {
        if (stack !is Cons) throw Exception(ctfromto + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctfromto + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctfromto + efloatexp)
        if (y !is Double) throw Exception(ctfromto + efloatexp)
        val i: Long = Math.round(x)
        var k: Long = Math.round(y)
        var res: Any = Nil()
        if (i <= k)
            while (i <= k) {  res = Cons(k.toDouble(),res) ; k = k - 1  }
        else
            while (i >= k) {  res = Cons(k.toDouble(),res) ; k = k + 1  }
        stack = Cons(res,stack)
    }

    fun fsum() {
        if (stack !is Cons) throw Exception(ctsum + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (!((x is Cons) or (x is Nil))) throw Exception(ctsum + elistexp)
        var i: Any = x
        var sum: Double = 0.0
        while (i is Cons) {
            if (i.addr !is Double) throw Exception(ctsum + elistofnumexp)
            sum = sum + (i.addr as Double)
            i = i.decr
        }
        stack = Cons(sum,stack)
    }

    fun fprod() {
        if (stack !is Cons) throw Exception(ctprod + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (!((x is Cons) or (x is Nil))) throw Exception(ctprod + elistexp)
        var i: Any = x
        var prod: Double = 1.0
        while (i is Cons) {
            if (i.addr !is Double) throw Exception(ctprod + elistofnumexp)
            prod = prod * (i.addr as Double)
            i = i.decr
        }
        stack = Cons(prod,stack)
    }

    fun fget() {
        if (stack !is Cons) throw Exception(ctget + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctget + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (!((x is Cons) or (x is Nil))) throw Exception(ctget + elistexp)
        //if (y !is Ident) throw Exception(ctget + eidentexp)
        var i: Any = x
        var a: Any
        var z: Any = idundef
        while (i is Cons) {
            a = i.addr
            i = i.decr
            if (i !is Cons) throw Exception(ctget + enonvalue)
            if (a == y) {  z = i.addr ; break  }
            i = i.decr
        }
        stack = Cons(z,stack)
    }

    fun fput() {
        if (stack !is Cons) throw Exception(ctput + estacknull)
        val z = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctput + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctput + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (!((x is Cons) or (x is Nil))) throw Exception(ctput + elistexp)
        //if (y !is Ident) throw Exception(ctput + eidentexp)
        var i: Any = x
        var a: Any
        var st: Any = Nil()
        while (i is Cons) {
            a = i.addr
            if (a == y) break
            st = Cons(a,st)
            i = i.decr
            if (i !is Cons) throw Exception(ctput + enonvalue)
            st = Cons(i.addr,st)
            i = i.decr
        }
        if (i is Cons) {
            i = i.decr
            if (i !is Cons) throw Exception(ctput + enonvalue)
            i = i.decr
        }
        i = Cons(y,Cons(z,i))  // i = Restliste
        while (st is Cons) {
            a = st
            st = st.decr
            a.decr = i
            i = a
        }
        stack = Cons(i,stack)
    }

    fun fkeys() {}

    fun fvalues() {}

    // concat is also for strings

    fun fsubstring() {
        if (stack !is Cons) throw Exception(ctsubstring + estacknull)
        val z = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctsubstring + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctsubstring + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is String) throw Exception(ctsubstring + estringexp)
        if (y !is Double) throw Exception(ctsubstring + efloatexp)
        if (z !is Double) throw Exception(ctsubstring + efloatexp)
        val s: String = x
        var i: Int = Math.round(y).toInt()
        var k: Int = Math.round(z).toInt()
        if (i < 1) i = 1
        if (i > s.length) i = s.length + 1
        if (k < 0) k = 0
        if ((i+k) > s.length) k = s.length + 1 - i
        stack = Cons(s.substring(i-1,i+k-1),stack)
    }

    fun findexof() {
        if (stack !is Cons) throw Exception(ctindexof + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctindexof + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is String) throw Exception(ctindexof + estringexp)
        if (y !is String) throw Exception(ctindexof + estringexp)
        stack = Cons((x.indexOf(y)+1).toDouble(),stack)
    }

    fun fupper() {
        if (stack !is Cons) throw Exception(ctupper + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is String) throw Exception(ctupper + estringexp)
        val z: String = x.uppercase()
        stack = Cons(z,stack)
    }

    fun flower() {
        if (stack !is Cons) throw Exception(ctlower + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is String) throw Exception(ctlower + estringexp)
        val z: String = x.lowercase()
        stack = Cons(z,stack)
    }

    fun fcapitalize() {
        if (stack !is Cons) throw Exception(ctcapitalize + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is String) throw Exception(ctcapitalize + estringexp)
        val z: String = x.replaceFirstChar{if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString()}
        stack = Cons(z,stack)
    }

    fun ftrim() {
        if (stack !is Cons) throw Exception(cttrim + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is String) throw Exception(cttrim + estringexp)
        val z: String = x.trim()
        stack = Cons(z,stack)
    }

    fun ftriml() {
        if (stack !is Cons) throw Exception(cttriml + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is String) throw Exception(cttriml + estringexp)
        val z: String = x.trimStart()
        stack = Cons(z,stack)
    }

    fun ftrimr() {
        if (stack !is Cons) throw Exception(cttrimr + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is String) throw Exception(cttrimr + estringexp)
        val z: String = x.trimEnd()
        stack = Cons(z,stack)
    }

    fun ftrimpre() {
        if (stack !is Cons) throw Exception(cttrimpre + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(cttrimpre + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is String) throw Exception(cttrimpre + estringexp)
        if (y !is String) throw Exception(cttrimpre + estringexp)
        val z: String = if (y.length > 0) x.trimStart(y[0])
                                     else x.trimStart()
        stack = Cons(z,stack)
    }

    fun fchr() {
        if (stack !is Cons) throw Exception(ctchr + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(ctchr + efloatexp)
        val z: String = Math.round(x).toInt().toChar().toString()
        stack = Cons(z,stack)
    }

    fun ford() {
        if (stack !is Cons) throw Exception(ctord + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is String) throw Exception(ctord + estringexp)
        if (x.length == 0) throw Exception(ctord + estringnull)
        stack = Cons(x[0].code.toDouble(),stack)
    }

    //  string old new replace
    fun freplace() {
        if (stack !is Cons) throw Exception(ctreplace + estacknull)
        val z = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctreplace + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctreplace + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is String) throw Exception(ctreplace + estringexp)
        if (y !is String) throw Exception(ctreplace + estringexp)
        if (z !is String) throw Exception(ctreplace + estringexp)
        stack = Cons(x.replace(y,z),stack)
    }

    fun freplace1() {
        if (stack !is Cons) throw Exception(ctreplace1 + estacknull)
        val z = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctreplace1 + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctreplace1 + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is String) throw Exception(ctreplace1 + estringexp)
        if (y !is String) throw Exception(ctreplace1 + estringexp)
        if (z !is String) throw Exception(ctreplace1 + estringexp)
        stack = Cons(x.replaceFirst(y,z),stack)
    }

    fun splitTo(str: String, dm: String): Any {
        var i: Int
        var s: String = str
        var list: Any = Nil()
        while (s.length > 0) {
            i = s.indexOf(dm)
            if (i == -1) {  list = Cons(s,list); s = ""  }
            else {  list = Cons(s.substring(0,i),list)
                s = s.substring(i+(dm.length),s.length)
            } }
        return nreverse(list)  }

    fun fsplit() {
        if (stack !is Cons) throw Exception(ctsplit + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctsplit + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is String) throw Exception(ctsplit + estringexp)
        if (y !is String) throw Exception(ctsplit + estringexp)
        stack = Cons(splitTo(x,y),stack)
    }

    fun fjoin() {
        if (stack !is Cons) throw Exception(ctjoin + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctjoin + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (!((x is Cons) or (x is Nil))) throw Exception(ctjoin + elistexp)
        if (y !is String) throw Exception(ctjoin + estringexp)
        var i: Any = x
        var s: String = ""
        var dm: String = ""
        while (i is Cons) {
            if (i.addr is String) s = s + (dm + i.addr)
            else s = s + (dm + toValue(i.addr))
            dm = y
            i = i.decr
        }
        stack = Cons(s,stack)
    }

    fun fi() {
        if (stack !is Cons) throw Exception(cti + estacknull)
        efun  = (stack as Cons).addr
        stack = (stack as Cons).decr
        eval()  }

    fun fdip() {
        if (stack !is Cons) throw Exception(ctdip + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctdip + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        efun = x
        eval()
        stack = Cons(y,stack)
    }

    fun fdip2() {
        if (stack !is Cons) throw Exception(ctdip2 + estacknull)
        val z = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctdip2 + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctdip2 + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        efun = z ; eval()
        stack = Cons(y,Cons(x,stack))
    }

    //  <stack> [ ... x ] nullary  --  <stack> x
    fun fnullary() {
        if (stack !is Cons) throw Exception(ctnullary + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        val st: Any = stack
        efun = x
        eval()
        if (stack !is Cons) throw Exception(ctnullary + estacknull)
        val res = (stack as Cons).addr
        //stack = (stack as Cons).decr
        stack = Cons(res,st)
    }

    //  <stack> [ ... x return ... x ] do  -- <stack> x
    fun fdo() {
        if (stack !is Cons) throw Exception(ctdo + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        val st: Any = stack
        try {  efun = x ; eval()  }
        catch(e: Exception) {
            val s: String = e.message.toString()
            if (s != ereturndo) throw Exception(s)   // mit fbreak correkt hier???
        }
        if (stack !is Cons) throw Exception(ctdo + estacknull)
        val res = (stack as Cons).addr
        //stack = (stack as Cons).decr
        stack = Cons(res,st)
    }

    fun freturn() {  throw Exception(ereturndo)  }

    fun fif() {
        if (stack !is Cons) throw Exception(ctif + estacknull)
        val z = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctif + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctif + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        when (x) {
            true  -> efun = y
            false -> efun = z
            else  -> throw Exception(ctif + eboolexp)
        }
        eval()
    }

    fun fbranch() {
        if (stack !is Cons) throw Exception(ctbranch + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctbranch + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctbranch + estacknull)
        val z = (stack as Cons).addr
        stack = (stack as Cons).decr
        when (z) {
            true  -> efun = y
            false -> efun = x
            else  -> throw Exception(ctbranch + eboolexp)
        }
        eval()  }

    fun fifte() {
        if (stack !is Cons) throw Exception(ctifte + estacknull)
        val z = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctifte + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctifte + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        //if (!((x is Cons) or (x is Nil))) throw Exception(ctifte + elistexp)  // ?
        //if (!((y is Cons) or (y is Nil))) throw Exception(ctifte + elistexp)  // ?
        //if (!((z is Cons) or (z is Nil))) throw Exception(ctifte + elistexp)  // ?
        val st: Any = stack
        efun = x
        eval()
        if (stack !is Cons) throw Exception(ctifte + estacknull)
        val b = (stack as Cons).addr
        stack = (stack as Cons).decr
        when (b) {
            true  -> efun = y
            false -> efun = z
            else  -> throw Exception(ctifte + eboolexp)
        }
        stack = st
        eval()
    }

    fun fchoice() {
        if (stack !is Cons) throw Exception(ctchoice + estacknull)
        val z = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctchoice + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctchoice + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        when (x) {
            true  -> stack = Cons(y,stack)
            false -> stack = Cons(z,stack)
            else  -> throw Exception(ctchoice + eboolexp)
        }  }

    fun fcase() {}

    fun fcond() {}

    fun ftimes() {     // val st: Any = stack ???
        if (stack !is Cons) throw Exception(cttimes + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(cttimes + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(cttimes + efloatexp)
        //if (!((y is Cons) or (y is Nil))) throw Exception(cttimes + elistexp)  // ?
        var n: Long = Math.round(x)
        while (n > 0) {
            efun = y
            eval()
            n = n - 1
        }  }

    fun fwhile() {     // val st: Any = stack ???
        if (stack !is Cons) throw Exception(ctwhile + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctwhile + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        //if (!((x is Cons) or (x is Nil))) throw Exception(ctwhile + elistexp)  // ?
        //if (!((y is Cons) or (y is Nil))) throw Exception(ctwhile + elistexp)  // ?
        var b: Any = false
        efun = x
        eval()
        if (stack !is Cons) throw Exception(ctwhile + estacknull)
        b = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (b !is Boolean) throw Exception(ctwhile + eboolexp)
        while (b as Boolean) {
            efun = y
            eval()
            efun = x
            eval()
            if (stack !is Cons) throw Exception(ctwhile + estacknull)
            b = (stack as Cons).addr
            stack = (stack as Cons).decr
            if (b !is Boolean) throw Exception(ctwhile + eboolexp)
        }  }

    //  [ ... break ... ] loop
    //  [ ... [ ... x return ... ] loop ... ] do     // correkt
    fun floop() {
        if (stack !is Cons) throw Exception(ctloop + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        try {  while (true) {  efun = x ; eval()  }  }
        catch(e: Exception) {
            val s: String = e.message.toString()
            if (s != ebreakloop) throw Exception(s)
        }  }

    fun fbreak() {  throw Exception(ebreakloop)  }

    fun fstep() {
        if (stack !is Cons) throw Exception(ctstep + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctstep + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (!((x is Cons) or (x is Nil))) throw Exception(ctstep + elistexp)
        //if (!((y is Cons) or (y is Nil))) throw Exception(ctstep + elistexp)  // ?
        var i: Any = x
        while (i is Cons) {
            stack = Cons(i.addr,stack)
            efun = y
            eval()
            i = i.decr
        }  }

    fun fmap() {
        if (stack !is Cons) throw Exception(ctmap + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctmap + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (!((x is Cons) or (x is Nil))) throw Exception(ctmap + elistexp)
        //if (!((y is Cons) or (y is Nil))) throw Exception(ctmap + elistexp)  // ?
        val st: Any = stack
        var i: Any = x
        var z: Any
        var res: Any = Nil()
        while (i is Cons) {
            stack = Cons(i.addr,st)
            efun = y
            eval()
            if (stack !is Cons) throw Exception(ctmap + estacknull)
            z = (stack as Cons).addr
            //stack = (stack as Cons).decr
            res = Cons(z,res)
            i = i.decr
        }
        stack = Cons(nreverse(res),st)
    }

    // [liste] zero [program] fold
    fun ffold() {
        if (stack !is Cons) throw Exception(ctfold + estacknull)
        val z = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctfold + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctfold + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (!((x is Cons) or (x is Nil))) throw Exception(ctfold + elistexp)
        //if (!((z is Cons) or (z is Nil))) throw Exception(ctfold + elistexp)  // ?
        val st: Any = stack
        var i: Any = x
        stack = Cons(y,st)
        while (i is Cons) {
            stack = Cons(i.addr,stack)
            efun = z
            eval()
            i = i.decr
        }
        if (stack !is Cons) throw Exception(ctfold + estacknull)
        val res = (stack as Cons).addr
        //stack = (stack as Cons).decr
        stack = Cons(res,st)
    }

    // [liste] [program] filter
    fun ffilter() {
        if (stack !is Cons) throw Exception(ctfilter + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctfilter + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (!((x is Cons) or (x is Nil))) throw Exception(ctfilter + elistexp)
        //if (!((y is Cons) or (y is Nil))) throw Exception(ctfilter + elistexp)  // ?
        val st: Any = stack
        var i: Any = x
        var b: Any
        var res: Any = Nil()
        while (i is Cons) {
            stack = Cons(i.addr,st)
            efun = y
            eval()
            if (stack !is Cons) throw Exception(ctfilter + estacknull)
            b = (stack as Cons).addr
            stack = (stack as Cons).decr  // ?
            if (b !is Boolean) throw Exception(ctfilter + eboolexp)
            if (b) {  res = Cons(i.addr,res)  }
            i = i.decr
        }
        stack = Cons(nreverse(res),st)
    }

    //  A [B] -> A1 A2
    fun fsplit2() {
        if (stack !is Cons) throw Exception(ctsplit2 + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctsplit2 + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (!((x is Cons) or (x is Nil))) throw Exception(ctsplit2 + elistexp)
        val st: Any = stack
        var i: Any = x
        var b: Any
        var a1: Any = Nil()
        var a2: Any = Nil()
        while (i is Cons) {
            stack = Cons(i.addr,st)
            efun = y
            eval()
            if (stack !is Cons) throw Exception(ctsplit2 + estacknull)
            b = (stack as Cons).addr
            stack = (stack as Cons).decr  // ?
            if (b !is Boolean) throw Exception(ctsplit2 + eboolexp)
            if (b) {  a1 = Cons(i.addr,a1)  }
            else   {  a2 = Cons(i.addr,a2)  }
            i = i.decr
        }
        stack = Cons(nreverse(a2),Cons(nreverse(a1),st))
    }

    // X [P1] [P2] -> R1 R2
    fun fcleave() {
        if (stack !is Cons) throw Exception(ctcleave + estacknull)
        val z = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctcleave + estacknull)
        val y = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctcleave + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        //if (!((y is Cons) or (y is Nil))) throw Exception(ctcleave + elistexp)  // ?
        //if (!((z is Cons) or (z is Nil))) throw Exception(ctcleave + elistexp)  // ?
        val st: Any = stack
        stack = Cons(x,st)
        efun = y
        eval()
        if (stack !is Cons) throw Exception(ctcleave + estacknull)
        val r1 = (stack as Cons).addr
        // stack = (stack as Cons).decr
        stack = Cons(x,st)
        efun = z
        eval()
        if (stack !is Cons) throw Exception(ctcleave + estacknull)
        val r2 = (stack as Cons).addr
        // stack = (stack as Cons).decr
        stack = Cons(r2,Cons(r1,st))
    }

    fun fprimrec() {
        if (stack !is Cons) throw Exception(ctprimrec + estacknull)
        val c = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctprimrec + estacknull)
        val i = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctprimrec + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        val st: Any = stack
        if (x is Double) {
            val z: Double = Math.round(x).toDouble()
            var n: Double = 1.0
            efun = i ; eval()
            while (n <= z) {
                stack = Cons(n,stack)
                efun = c ; eval()
                n = n + 1.0
            }
        } else if ((x is Cons) or (x is Nil)) {
            var k: Any = x
            efun = i ; eval()
            while (k is Cons) {
                stack = Cons(k.addr,stack)
                efun = c ; eval()
                k = k.decr
            }
        } else throw Exception(ctprimrec + elistornumexp)
        if (stack !is Cons) throw Exception(ctprimrec + estacknull)
        val r = (stack as Cons).addr
        //stack = (stack as Cons).decr
        stack = Cons(r,st)
    }

    //  [P] [T] [R1] tailrec -> ...
    fun ftailrec() {
        if (stack !is Cons) throw Exception(cttailrec + estacknull)
        val r1 = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(cttailrec + estacknull)
        val t = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(cttailrec + estacknull)
        val p = (stack as Cons).addr
        stack = (stack as Cons).decr
        var b: Any
        while (true) {
            efun = p ; eval()
            if (stack !is Cons) throw Exception(cttailrec + estacknull)
            b = (stack as Cons).addr
            stack = (stack as Cons).decr
            if (b !is Boolean) throw Exception(cttailrec + eboolexp)
            if (b) {  efun = t  ; eval() ; break  }
            else   {  efun = r1 ; eval()  }
        }  }

    fun fgenrec() {
        if (stack !is Cons) throw Exception(ctgenrec + estacknull)
        val be2 = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctgenrec + estacknull)
        val be1 = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctgenrec + estacknull)
        val bth = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctgenrec + estacknull)
        val bif = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (!((bif is Cons) or (bif is Nil))) throw Exception(ctgenrec + elistexp)
        if (!((bth is Cons) or (bth is Nil))) throw Exception(ctgenrec + elistexp)
        if (!((be1 is Cons) or (be1 is Nil))) throw Exception(ctgenrec + elistexp)
        if (!((be2 is Cons) or (be2 is Nil))) throw Exception(ctgenrec + elistexp)
        val st: Any = stack
        efun = bif ; eval()
        if (stack !is Cons) throw Exception(ctgenrec + estacknull)
        val b = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (b !is Boolean) throw Exception(ctgenrec + eboolexp)
        stack = st
        if (b) {  efun = bth ; eval()  }
        else {
            efun = be1 ; eval()
            stack = Cons(Cons(bif,Cons(bth,Cons(be1,Cons(be2,Cons(idgenrec,Nil()))))),stack)
            efun = be2 ; eval()
        }  }

    fun flinrec() {
        if (stack !is Cons) throw Exception(ctlinrec + estacknull)
        val be2 = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctlinrec + estacknull)
        val be1 = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctlinrec + estacknull)
        val bth = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctlinrec + estacknull)
        val bif = (stack as Cons).addr
        stack = (stack as Cons).decr
        //if (!((bif is Cons) or (bif is Nil))) throw Exception(ctlinrec + elistexp)
        //if (!((bth is Cons) or (bth is Nil))) throw Exception(ctlinrec + elistexp)
        //if (!((be1 is Cons) or (be1 is Nil))) throw Exception(ctlinrec + elistexp)
        //if (!((be2 is Cons) or (be2 is Nil))) throw Exception(ctlinrec + elistexp)
        val st: Any = stack
        efun = bif ; eval()
        if (stack !is Cons) throw Exception(ctlinrec + estacknull)
        val b = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (b !is Boolean) throw Exception(ctlinrec + eboolexp)
        stack = st
        if (b) {  efun = bth ; eval()  }
        else {
            efun = be1 ; eval()
            stack = Cons(be2,Cons(be1,Cons(bth,Cons(bif,stack))))
            flinrec()
            efun = be2 ; eval()
        }  }

    fun fbinrec() {
        if (stack !is Cons) throw Exception(ctbinrec + estacknull)
        val be2 = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctbinrec + estacknull)
        val be1 = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctbinrec + estacknull)
        val bth = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (stack !is Cons) throw Exception(ctbinrec + estacknull)
        val bif = (stack as Cons).addr
        stack = (stack as Cons).decr
        //if (!((bif is Cons) or (bif is Nil))) throw Exception(ctbinrec + elistexp)
        //if (!((bth is Cons) or (bth is Nil))) throw Exception(ctbinrec + elistexp)
        //if (!((be1 is Cons) or (be1 is Nil))) throw Exception(ctbinrec + elistexp)
        //if (!((be2 is Cons) or (be2 is Nil))) throw Exception(ctbinrec + elistexp)
        val st: Any = stack
        efun = bif ; eval()
        if (stack !is Cons) throw Exception(ctbinrec + estacknull)
        val b = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (b !is Boolean) throw Exception(ctbinrec + eboolexp)
        stack = st
        if (b) {  efun = bth ; eval()  }
        else {
            efun = be1 ; eval()
            //val reQt = Cons(bif,Cons(bth,Cons(be1,Cons(be2,Cons(idbinrec,Nil())))))
            val y = (stack as Cons).addr
            stack = (stack as Cons).decr
            //val x = (stack as Cons).addr
            //stack = (stack as Cons).decr
            //
            //stack = Cons(x,stack)
            stack = Cons(be2,Cons(be1,Cons(bth,Cons(bif,stack))))
            fbinrec()
            //efun = reQt ; eval()
            stack = Cons(y,stack)
            stack = Cons(be2,Cons(be1,Cons(bth,Cons(bif,stack))))
            fbinrec()
            //efun = reQt ; eval()
            efun = be2 ; eval()
        }  }

    // [program] try -- stack  []/"..."           (test!)
    fun ftry() {
        if (stack !is Cons) throw Exception(cttry + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        val st: Any = stack
        try {
            efun = x
            eval()
            stack = Cons(Nil(),Cons(stack,st))
        } catch (e: Exception) {
            val s: String = e.message.toString()
            if (s == ecalcstop) throw Exception(ecalcstop)
            else stack = Cons(s,Cons(stack,st))
        }  }

    fun fabort() {
        runvm = false
        throw Exception(ecalcstop)
    }

    fun ferror() {
        if (stack !is Cons) throw Exception(cterror + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is String) throw Exception(cterror + estringexp)
        throw Exception(x)
    }

    fun fsize() {
        if (stack !is Cons) throw Exception(ctsize + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        when (x) {
            is Cons   -> {  var len: Long = 0
                            var i: Any = x
                            while (i is Cons) {  len = len + 1 ; i = i.decr  }
                            stack = Cons(len.toDouble(),stack)
                         }
            is String -> stack = Cons(x.length.toDouble(),stack)
            is Nil    -> stack = Cons(0.0,stack)
            else      -> throw Exception(ctsize + elistorstrexp)
        }  }

    fun funpack() {
        if (stack !is Cons) throw Exception(ctunpack + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is String) throw Exception(ctunpack + estringexp)
        val s: String = x
        var n: Int = s.length
        var res: Any = Nil()
        while (n > 0) {  res = Cons(s.substring(n-1,n),res) ; n = n - 1  }
        stack = Cons(res,stack)
    }

    fun fpack() {
        if (stack !is Cons) throw Exception(ctpack + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (!((x is Cons) or (x is Nil))) throw Exception(ctpack + elistofstrexp)
        var i: Any = x
        var s: String = ""
        while (i is Cons) {
            if (i.addr !is String) throw Exception(ctpack + elistofstrexp)
            s = s + i.addr
            i = i.decr
        }
        stack = Cons(s,stack)
    }

    fun fparse() {
        if (stack !is Cons) throw Exception(ctparse + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is String) throw Exception(ctparse + estringexp)
        val res: Any = parse(x)
        stack = Cons(res,stack)
    }

    fun ftostr() {
        if (stack !is Cons) throw Exception(cttostr + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        stack = Cons(toValue(x),stack)
    }

    fun ftoval() {
        if (stack !is Cons) throw Exception(cttoval + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is String) throw Exception(cttoval + estringexp)
        val z: Any = parse(x)
        if (z is Cons) stack = Cons(z.addr,stack)
        else stack = Cons(idundef,stack)
    }

    fun ftrytoval() {
        if (stack !is Cons) throw Exception(cttrytoval + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is String) throw Exception(cttrytoval + estringexp)
        try {
            val z: Any = parse(x)
            if (z is Cons) stack = Cons(Nil(),Cons(z.addr,stack))
            else stack = Cons(Nil(),Cons(idundef,stack))
        } catch(e: Exception) {
            stack = Cons(e.message.toString(),Cons(idundef,stack))
        }  }

    fun fstrtod() {
        if (stack !is Cons) throw Exception(ctstrtod + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is String) throw Exception(ctstrtod + estringexp)
        if (isDouble(x)) stack = Cons(x.toDouble(),stack)
        else stack = Cons(idundef,stack)
    }

    /*
    @kotlin.ExperimentalStdlibApi
    fun fhextod() {
        if (stack !is Cons) throw Exception(cthextod + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is String) throw Exception(cthextod + estringexp)
        try {
            val z: Double = x.hexToLong().toDouble()
            stack = Cons(z,stack)
        } catch(e: Exception) {
            stack = Cons(idundef,stack)
        }  }
    */

    /*
    @kotlin.ExperimentalStdlibApi
    fun ftohex() {
        if (stack !is Cons) throw Exception(cttohex + estacknull)
        val x = (stack as Cons).addr
        stack = (stack as Cons).decr
        if (x !is Double) throw Exception(cttohex + efloatexp)
        var z: String = x.toLong().toHexString().trimStart('0')
        if (z.isEmpty()) z = "0"
        stack = Cons(z,stack)
    }
    */

    fun fidentlist() {  stack = Cons(identlist,stack)  }  // SideEffect -> words

    fun fidentdump() {
        var i: Any = identlist
        var a: Any
        var s: String = ""
        var ln: String = ""
        while (i is Cons) {
            a = i.addr
            if (a is Ident) {
                when (a.body) {
                    is Nil  -> s += ln + a.pname
                    is Int  -> s += ln + a.pname + " == " + toValue(a.body)
                    is Cons -> s += ln + a.pname + " == " + toSequence(a.body)
                    else    -> s += ln + a.pname + " == " + "(???)"
                }  }
            ln = "\n"
            i = i.decr
        }
        stack = Cons(s,stack)     // SideEffect -> dump
    }

    fun fhelpinfo() {  stack = Cons(helpPDF,stack)  }  // SideEffect -> help

    /*
    fun calc(txt: String) {
        val clist: Any = parse(txt)
        if (clist is Cons) {
            if ((clist.addr is Ident) and (clist.decr is Cons)) {
                val id: Ident = clist.addr as Ident
                val dlist: Cons = clist.decr as Cons
                if (dlist.addr == iddef) {
                    id.info = txt
                    id.body = dlist.decr
                } else run(clist)
            } else run(clist)
        }  } // function-use in try einbetten

    */
    fun deflines(lines: Any): String {
        var list = lines
        var line: Any
        var clist: Any
        var id: Ident
        var dlist: Cons
        var res: String = ""
        var ln: String = ""
        try {
            while (list is Cons) {
                line = list.addr
                list = list.decr
                if (line is String) {
                    clist = parse(line)
                    if (clist is Cons) {
                        if ((clist.addr is Ident) and (clist.decr is Cons)) {
                            id = clist.addr as Ident
                            dlist = clist.decr as Cons
                            if (dlist.addr == iddef) {
                                id.info = line
                                id.body = dlist.decr
                                res = res + (ln + id.pname+" == "+toSequence(id.body))
                                ln = "\n"
                            } else {}
                        } else {}
                    } else {}
                } else throw Exception(ctdeflines + elistofstrexp)
            }
            return res
        } catch(e: Exception) {  return "ERROR: "+e.message  }
    }

    fun fgc() {  System.gc()  }

    fun prelude(): String {
        return  "\n" +
                "ifundef  == [undef] dip2 if\n" +
                "ifstring == [string] dip2 if\n" +
                "iffloat == [float] dip2 if\n" +
                "ifident == [ident] dip2 if\n" +
                "ifbool  == [bool] dip2 if\n" +
                "ifconsp == [consp] dip2 if\n" +
                "iflist  == [list] dip2 if\n" +
                "ifnull  == [null] dip2 if\n" +
                "init == dup size pred take\n" +
                "last == dup size at\n" +
                "rolldownd == [rolldown] dip\n" +
                "rollupd == [rollup] dip\n" +
                "rotated == [rotate] dip\n" +
                "swapd == [swap] dip\n" +
                "popd == [pop] dip\n" +
                "dupd == [dup] dip\n" +
                "fact == iota 1 [*] fold\n" +  // prod ?
                "Y == dup [] cons [Y] concat swap i\n" +
                "clear == [] unstack\n" +  // newstack ?
                "enconcat == [swap] dip cons concat\n" +
                "qsort == [small] [] [uncons [>] split2] [enconcat] binrec\n" +
                "pair == [] cons cons\n" +
                "unpair == uncons uncons pop\n" +
                ".s == stack reverse print\n" +
                ". == 1 [] '!\n" +
                "print == 2 [] '!\n" +
                "load  == 3 [] '!\n" +
                "save  == 4 [] '!\n" +
                "floadtext == 5 [] '!\n" +
                "fsavetext == 6 [] '!\n" +
                "files == 7 [] '!\n" +
                "fremove == 8 [] '!\n" +
                "frename == 9 [] '!\n" +
                "time == 10 [] '!\n" +
                "calc == 11 [] '!\n" +
                "dump  == identdump print\n" +
                "words == identlist print\n" +
                "help  == helpinfo print\n"

    }

}  // class JoyVM

fun isTopIdent(st: Any, id: Ident): Boolean {
    if (st is Cons) return (st.addr == id)
    else return false
}

// ab hier in mainactivity einsetzen !!!
/*
const val ctnullpar: String = "(null)"

var vm = JoyVM()
var itxt: String = vm.prelude()
var otxt: String = vm.deflines(vm.splitTo(itxt,"\n"))
*/


fun main() {
    try {
        // var vm...
        //println("PRELUDE: \n"+otxt)
        //vm.calc("loop1 == dup [.] [1 + [100 >=] [] [loop1] ifte ] '!")
        //vm.calc("loop2 == dup [.] [1 + [200 >=] [] [loop2] ifte ] '!")
        //vm.calc("Y == dup [] cons [Y] concat swap i")
        //vm.calc("qsort == [small] [] [uncons [>] split2] [enconcat] binrec")
        //vm.calc("10 20 30")
        //vm.calc("[ [5 /][3 /] cleave] try null [unpair swap] ['nix] if")
        //vm.calc("\"abc;def;ghi;jkl;\" \";\" split")

        //vm.calc("peter == [id 2 dup +]") // × ÷ 10 [dup dup 0 > [1 -] [10 0 / break] if] loop
        vm.calc("123 ['then] ['else] ifident")

        //runvm = true
        //while (isTopIdent(stack,vm.idact)) {  doAct()  }

        println("identlist = "+toValue(vm.identlist))
        println("stack = "+toSequence(vm.creverse(stack)))
        //println("prelude = "+toValue(vm.deflines(vm.splitTo(txt,"\n"))))
    } catch (e: Exception) {
        println("ERROR:   "+e.message)
    }

}